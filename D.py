MOD = 998244353

N = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

MAX_N = 3001

# dp[i][c] : i番目の状態の場合に、cの値を固定して、(ai ≤ c ≤ bi)を満たす場合の数が、どれくらい存在するのか数え上げる。
# 例) dp[0][1] : 0番目の状態の場合にcの値を1に固定する。(a0 ≤ 1 ≤ b0)を満たす、場合の数がどれくらい存在するのか数え上げる。
# 例) dp[2][3] : 2番目の状態の場合にcの値を3に固定する。(a2 ≤ 3 ≤ b2)を満たす、場合の数がどれくらい存在するのか数え上げる。
dp = [[0] * MAX_N for _ in range(N + 1)]

# 初期化を行う。
# 0番目の状態の場合に、cの値を0とする。確実に(a0 ≤ 0 ≤ b0)を満たす場合の数は、1通りとなる。
# c=1の時、c=2の時、c=3の時、、、の場合は、a0, b0の値が変化することにより、初期化段階では決められないので0としておく。
dp[0][0] = 1

# i回状態遷移を行う。
for i in range(N):
    # aiの値をtmpAとする。
    tmpA = A[i]
    # biの値をtmpAとする。
    tmpB = B[i]

    # tmpAよりも小さい値 && (ai-1 ≤ tmpAよりも小さい値 ≤ bi-1)を満たす場合の数の、総和を演算しておく。
    s = sum(dp[i][:tmpA]) % MOD

    # (ai ≤ ci ≤ bi)を満たす箇所のみ、状態の更新を行う。
    for c in range(tmpA, tmpB + 1):
        # tmpAとcが同値の場合の場合の数を演算する。
        # cの値が+1されるごとに、一つ前のcの値も、場合の数に含められるので、s += を実行している。
        s += dp[i][c]

        s %= MOD
        dp[i + 1][c] = s

# N番目の状態の場合に、cの値を固定して、(aN ≤ c ≤ bN)を満たす場合の数が、どれくらい存在するのか総和する。
print(sum(dp[N]) % MOD)
